// PBRWaterBody.cs
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class PBRWaterBody : MonoBehaviour
{
    [Tooltip("The Rigidbody component of this object.")]
    public Rigidbody rb;

    [Header("Buoyancy Settings")]
    [Tooltip("Local-space points where buoyancy forces will be applied. More points provide more stable physics.")]
    public Vector3[] buoyancySamplePoints;
    [Tooltip("Multiplier for the buoyant force. Higher values make the object float more strongly.")]
    public float buoyancyMultiplier = 1.2f;
    [Tooltip("Drag applied when the sample point is underwater.")]
    public float submergedDrag = 3.0f;
    [Tooltip("Angular drag applied when the sample point is underwater.")]
    public float submergedAngularDrag = 1.5f;

    [Header("Interaction Trigger Settings")]
    [Tooltip("Triggers a splash effect when a sample point goes this deep below the dynamic surface.")]
    public float interactionDepthThreshold = 0.2f;
    [Tooltip("Vertical velocity required to trigger a splash effect.")]
    public float interactionVelocityThresholdY = 1.5f;
    [Tooltip("Radius of the splash ripple effect generated by this object.")]
    public float interactionRadius = 1.5f;
    [Tooltip("Minimum time between splash effects from this object.")]
    public float interactionCooldown = 0.5f;

    private float _lastInteractionTime = -100f;
    private float _pointVolume;
    private const float WATER_DENSITY = 1000f; // kg/m^3

    void Awake()
    {
        rb = GetComponent<Rigidbody>();
        if (!gameObject.CompareTag("WaterPhysicsBody"))
        {
            Debug.LogWarning($"Object '{name}' has a PBRWaterBody script but is not tagged 'WaterPhysicsBody'. It will not be affected by water physics.", this);
        }
    }

    void Start()
    {
        if (buoyancySamplePoints.Length == 0)
        {
            Debug.LogWarning($"'{name}' has no buoyancySamplePoints defined. Buoyancy will not be applied.", this);
            return;
        }
        _pointVolume = rb.mass / (WATER_DENSITY * buoyancySamplePoints.Length);
    }

    /// <summary>
    /// This method is called by the PBRWaterManager during FixedUpdate.
    /// </summary>
    public void ApplyForces(PBRWaterManager manager)
    {
        if (buoyancySamplePoints.Length == 0) return;

        float currentTime = Time.fixedTime;
        // FIXED: Access the 'y' component of the new 'waterOrigin' vector
        float baseWaterHeight = manager.waterOrigin.y;
        
        // Apply buoyancy force at each sample point
        foreach (Vector3 localPoint in buoyancySamplePoints)
        {
            Vector3 worldPoint = transform.TransformPoint(localPoint);
            Vector3 waveDisplacement = manager.GetWaveDisplacementAt(worldPoint, currentTime);
            float dynamicWaterLevel = baseWaterHeight + waveDisplacement.y;

            if (worldPoint.y < dynamicWaterLevel)
            {
                float submersionDepth = dynamicWaterLevel - worldPoint.y;
                float buoyantForceMagnitude = submersionDepth * _pointVolume * WATER_DENSITY * -Physics.gravity.y * buoyancyMultiplier;
                rb.AddForceAtPosition(Vector3.up * buoyantForceMagnitude, worldPoint, ForceMode.Force);
            }
        }
        
        // Calculate overall drag based on the number of submerged points
        int submergedPoints = 0;
        foreach (Vector3 localPoint in buoyancySamplePoints)
        {
            Vector3 worldPoint = transform.TransformPoint(localPoint);
            // FIXED: Use baseWaterHeight here as well
            if (worldPoint.y < baseWaterHeight + manager.GetWaveDisplacementAt(worldPoint, currentTime).y)
            {
                submergedPoints++;
            }
        }
        float submergedRatio = (float)submergedPoints / buoyancySamplePoints.Length;
        rb.drag = Mathf.Lerp(0.1f, submergedDrag, submergedRatio);
        rb.angularDrag = Mathf.Lerp(0.1f, submergedAngularDrag, submergedRatio);
        
        // Check for Interaction Trigger
        if (currentTime - _lastInteractionTime > interactionCooldown)
        {
            foreach (Vector3 localPoint in buoyancySamplePoints)
            {
                Vector3 worldPoint = transform.TransformPoint(localPoint);
                Vector3 waveDisplacement = manager.GetWaveDisplacementAt(worldPoint, currentTime);
                // FIXED: And again here
                float dynamicWaterLevel = baseWaterHeight + waveDisplacement.y;
                float pointDepth = dynamicWaterLevel - worldPoint.y;
                float pointVerticalVelocity = rb.GetPointVelocity(worldPoint).y;

                if (pointDepth > interactionDepthThreshold && pointVerticalVelocity < -interactionVelocityThresholdY)
                {
                    Vector3 surfacePoint = new Vector3(worldPoint.x + waveDisplacement.x, dynamicWaterLevel, worldPoint.z + waveDisplacement.z);
                    manager.TriggerInteractionEvent(surfacePoint, interactionRadius);
                    _lastInteractionTime = currentTime;
                    return;
                }
            }
        }
    }
}